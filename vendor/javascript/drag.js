import{whitePov as e,getKeyAtDomPos as t,canMove as r,selectSquare as o,isDraggable as n,unsetPremove as s,unsetPredrop as a,dropNewPiece as c,userMove as i,callUserFunction as l,unselect as g}from"./board.js";import{eventPosition as d,key2pos as u,posToTranslate as f,translate as p,setVisible as m,computeSquareCenter as b,distanceSq as h,samePiece as y}from"./util.js";import{clear as v}from"./draw.js";import{anim as w}from"./anim.js";import"./premove.js";import"./types.js";function start(c,i){if(!(c.trustAllEvents||i.isTrusted))return;if(i.buttons!==void 0&&i.buttons>1)return;if(i.touches&&i.touches.length>1)return;const l=c.dom.bounds(),g=d(i),b=t(g,e(c),l);if(!b)return;const h=c.pieces.get(b);const y=c.selected;y||!c.drawable.enabled||!c.drawable.eraseOnClick&&h&&h.color===c.turnColor||v(c);if(i.cancelable!==false&&(!i.touches||c.blockTouchScroll||h||y||pieceCloseTo(c,g)))i.preventDefault();else if(i.touches)return;const D=!!c.premovable.current;const C=!!c.predroppable.current;c.stats.ctrlKey=i.ctrlKey;c.selected&&r(c,c.selected,b)?w((e=>o(e,b)),c):o(c,b);const P=c.selected===b;const E=pieceElementByKey(c,b);if(h&&E&&P&&n(c,b)){c.draggable.current={orig:b,piece:h,origPos:g,pos:g,started:c.draggable.autoDistance&&c.stats.dragged,element:E,previouslySelected:y,originTarget:i.target,keyHasChanged:false};E.cgDragging=true;E.classList.add("dragging");const t=c.dom.elements.ghost;if(t){t.className=`ghost ${h.color} ${h.role}`;p(t,f(l)(u(b),e(c)));m(t,true)}processDrag(c)}else{D&&s(c);C&&a(c)}c.dom.redraw()}function pieceCloseTo(t,r){const o=e(t),n=t.dom.bounds(),s=Math.pow(n.width/8,2);for(const e of t.pieces.keys()){const t=b(e,o,n);if(h(t,r)<=s)return true}return false}function dragNewPiece(e,t,r,o){const n="a0";e.pieces.set(n,t);e.dom.redraw();const s=d(r);e.draggable.current={orig:n,piece:t,origPos:s,pos:s,started:true,element:()=>pieceElementByKey(e,n),originTarget:r.target,newPiece:true,force:!!o,keyHasChanged:false};processDrag(e)}function processDrag(r){requestAnimationFrame((()=>{var o;const n=r.draggable.current;if(!n)return;((o=r.animation.current)===null||o===void 0?void 0:o.plan.anims.has(n.orig))&&(r.animation.current=void 0);const s=r.pieces.get(n.orig);if(s&&y(s,n.piece)){!n.started&&h(n.pos,n.origPos)>=Math.pow(r.draggable.distance,2)&&(n.started=true);if(n.started){if(typeof n.element==="function"){const e=n.element();if(!e)return;e.cgDragging=true;e.classList.add("dragging");n.element=e}const o=r.dom.bounds();p(n.element,[n.pos[0]-o.left-o.width/16,n.pos[1]-o.top-o.height/16]);n.keyHasChanged||(n.keyHasChanged=n.orig!==t(n.pos,e(r),o))}}else cancel(r);processDrag(r)}))}function move(e,t){e.draggable.current&&(!t.touches||t.touches.length<2)&&(e.draggable.current.pos=d(t))}function end(r,o){const n=r.draggable.current;if(!n)return;o.type==="touchend"&&o.cancelable!==false&&o.preventDefault();if(o.type==="touchend"&&n.originTarget!==o.target&&!n.newPiece){r.draggable.current=void 0;return}s(r);a(r);const u=d(o)||n.pos;const f=t(u,e(r),r.dom.bounds());if(f&&n.started&&n.orig!==f)if(n.newPiece)c(r,n.orig,f,n.force);else{r.stats.ctrlKey=o.ctrlKey;i(r,n.orig,f)&&(r.stats.dragged=true)}else if(n.newPiece)r.pieces.delete(n.orig);else if(r.draggable.deleteOnDropOff&&!f){r.pieces.delete(n.orig);l(r.events.change)}(n.orig!==n.previouslySelected&&!n.keyHasChanged||n.orig!==f&&f)&&r.selectable.enabled||g(r);removeDragElements(r);r.draggable.current=void 0;r.dom.redraw()}function cancel(e){const t=e.draggable.current;if(t){t.newPiece&&e.pieces.delete(t.orig);e.draggable.current=void 0;g(e);removeDragElements(e);e.dom.redraw()}}function removeDragElements(e){const t=e.dom.elements;t.ghost&&m(t.ghost,false)}function pieceElementByKey(e,t){let r=e.dom.elements.board.firstChild;while(r){if(r.cgKey===t&&r.tagName==="PIECE")return r;r=r.nextSibling}}export{cancel,dragNewPiece,end,move,start};
//# sourceMappingURL=drag.js.map
